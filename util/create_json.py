"""Create_Annotations_JSON.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o8aFID-Kz7GJV764eSTGQTEwlnkGLz6w
"""

from PIL import Image
import matplotlib.pyplot as plt
import numpy as np
import glob
import re
import time
import sys

def sort_list(l):
    convert = lambda text: int(text) if text.isdigit() else text
    alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)]
    return sorted(l, key = alphanum_key)

def create_image(dirname, dirname2, label):
    if dirname[-1] == "/":
        dirname = dirname[:-1]
    images = glob.glob(str(dirname) + "/*.png")

    # Sort images alphanumerically by filename to ensure that z loops from front to back
    images = sort_list(images)
    images2 = glob.glob(str(dirname2) + "/*")
    images2 = sort_list(images2)

    p = np.zeros((len(images), Image.open(images2[0]).convert('L').size[0]))

    # setup toolbar
    toolbar_width = int(len(images)/5 + 1)
    sys.stdout.write(label + " [%s]" % (" " * toolbar_width))
    sys.stdout.flush()
    sys.stdout.write("\b" * (toolbar_width+1))

    # Loop through CT slices from front to back
    for z in range(len(images)):
        img = Image.open(images[z]).convert('L')  # convert image to 8-bit grayscale
        img2 = Image.open(images2[z]).convert('L')
        h, w = img2.size
        img = img.resize((h, w))
        HEIGHT, WIDTH = img.size

        data = list(img.getdata()) # convert image data to a list of integers
        # convert that to 2D list (list of lists of integers)
        pixels = [data[offset:offset+WIDTH] for offset in range(0, WIDTH*HEIGHT, WIDTH)]

        # Loop from left to right on the CT slice
        for x in range(WIDTH):
            # Sum y values in the current x column
            sum = 0
            for y in range(HEIGHT):
                sum += pixels[y][x]
            # Assign sum to the point (x, z) on the coronal image - p[z][x] in the pixel array, 
            # since z represents height (rows) and x represents length (columns)
            p[len(images) - 1 - z][x] = sum

        if z % 5 == 0:
            # update the bar
            sys.stdout.write("-")
            sys.stdout.flush()
    sys.stdout.write("]\n")

    filename = 'img.jpg'

    array = np.array(p, dtype=np.uint8)
    xray = Image.fromarray(array)
    xray.save(filename)
    
    final_img = Image.open(filename)
    size = 300
    if final_img.size[1] < 300:
        final_img = final_img.resize((final_img.size[0], 300))    

    final_img.save(filename)

    ret = []
    ret.append(final_img)
    ret.append(len(images))

    return ret

# Commented out IPython magic to ensure Python compatibility.
# %cdÂ /content/drive/My Drive/

ret = []

thresh = 200

def floodfill(x, y):
    if matrix[x][y] > thresh: 
        matrix[x][y] = 0 
        ret.append((x,y))
        if x > 0:
            floodfill(x-1,y)
        if x < matrix.shape[0] - 1:
            floodfill(x+1,y)
        if y > 0:
            floodfill(x,y-1)
        if y < matrix.shape[1] - 1:
            floodfill(x,y+1)

def flood():
    arr = []
    for r in range(matrix.shape[0]):
        for c in range(matrix.shape[1]):
            if (matrix[r][c] > thresh):
                ret.clear()
                floodfill(r, c)
                m = []
                for i in ret:
                    m.append(i)
                arr.append(m)
    return arr

import json
import random
import numpy as np
from scipy.spatial import ConvexHull
import matplotlib.pyplot as plt

from ConcaveHull import ConcaveHull

sys.setrecursionlimit(300000)
data = {}

def show(index):
    ans = [] 
    a = arr[index]
    x = []
    y = []
    for tup in a:
      x.append(tup[0])
      y.append(tup[1])

    allPoints=np.column_stack((x,y))


    # hull = ConvexHull(allPoints)

    ch = ConcaveHull()
    ch.loadpoints(allPoints)
    ch.calculatehull()

    boundary_points = np.vstack(ch.boundary.exterior.coords.xy).T

    xs = []
    ys = []

    # for simplex in hull.simplices:
    #     ans.append((allPoints[simplex, 0][0], allPoints[simplex, 1][0]))
    #     xs.append(allPoints[simplex, 0][0])
    #     ys.append(allPoints[simplex, 1][0])

    for r in range(len(boundary_points)):
        ans.append((boundary_points[r][0], boundary_points[r][1]))
        xs.append(boundary_points[r][0])
        ys.append(boundary_points[r][1])
    
    # plt.scatter(xs, ys, label= "o", color= "red",  
    #         marker= "o", s=30) 
    # plt.show()

    return ans

scan_list = glob.glob('/Users/vignavramesh/Downloads/scans/*')
mask_list = glob.glob('/Users/vignavramesh/Downloads/masks/*')
scan_list = sort_list(scan_list)
mask_list = sort_list(mask_list)

for i in range(42,241):
    mask_name = mask_list[i-42]
    scan_name = scan_list[i-42]
    ret = create_image(mask_name, scan_name, 'Creating mask ' + str(i) + ':')
    img = ret[0]
    l = ret[1]
    W, H = img.size
    img = img.resize((432, H))
    WIDTH, HEIGHT = img.size
    d = list(img.getdata()) 
    d = [d[offset:offset+WIDTH] for offset in range(0, WIDTH*HEIGHT, WIDTH)]
    matrix = np.asarray(d).astype(np.uint8)

    l = float(l)
    arr = flood()
   
    size = int(l * 21.5895 + 5965.85)
    fname = 'xray' + str(i) + '.jpg'
    name = fname + str(size)
    
    regions = []
    
    for idx in range(len(arr)):
        t = arr[idx]
        if (min(t)[0] == max(t)[0] or min(t, key = lambda q: q[1])[1] == max(t, key = lambda q: q[1])[1]):
            continue
        a = show(idx)
        all_points_x = []
        all_points_y = []
        for tup in a:
            all_points_x.append(int(tup[0]))
            all_points_y.append(int(tup[1]))
    
        shape_attributes = {}
        shape_attributes['name'] = 'polygon'
        shape_attributes['all_points_x'] = all_points_y
        shape_attributes['all_points_y'] = all_points_x

        image_quality = {}
        image_quality['good'] = True
        image_quality['frontal'] = True
        image_quality['good_illumination'] = True

        region_attributes = {}
        region_attributes['name'] = 'not_defined'
        region_attributes['type'] = 'unknown'
        region_attributes['image_quality'] = image_quality
        
        regions.append({
            'shape_attributes':shape_attributes,
            "region_attributes": region_attributes
        })

    file_attributes = {}
    file_attributes['caption'] = ''
    file_attributes['public_domain'] = 'no'
    file_attributes['image_url'] = ''

    data[name] = {}
    data[name]['filename'] = fname
    data[name]['size'] = size
    data[name]['regions'] = regions
    data[name]['file_attributes'] = file_attributes

with open('via_region_data.json', 'w') as outfile:
    json.dump(data, outfile)